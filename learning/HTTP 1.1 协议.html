<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP/1.1 协议 | 桂伦铝&#39;s blog</title>
    <meta name="description" content="我的个人博客">
    
    
    <link rel="preload" href="/assets/css/0.styles.6ba01dbc.css" as="style"><link rel="preload" href="/assets/js/app.289f11c2.js" as="script"><link rel="preload" href="/assets/js/2.8eeab113.js" as="script"><link rel="prefetch" href="/assets/js/10.8070f52e.js"><link rel="prefetch" href="/assets/js/11.cb6635c7.js"><link rel="prefetch" href="/assets/js/12.c3efe479.js"><link rel="prefetch" href="/assets/js/13.5a368510.js"><link rel="prefetch" href="/assets/js/14.df0aa962.js"><link rel="prefetch" href="/assets/js/15.5265b3db.js"><link rel="prefetch" href="/assets/js/16.338bc09c.js"><link rel="prefetch" href="/assets/js/17.4f9c78c9.js"><link rel="prefetch" href="/assets/js/18.4d7fcbb4.js"><link rel="prefetch" href="/assets/js/19.f6a750a4.js"><link rel="prefetch" href="/assets/js/3.3ec3aa2f.js"><link rel="prefetch" href="/assets/js/4.df3f4e19.js"><link rel="prefetch" href="/assets/js/5.f4ce5be6.js"><link rel="prefetch" href="/assets/js/6.58c6a691.js"><link rel="prefetch" href="/assets/js/7.04711ce5.js"><link rel="prefetch" href="/assets/js/8.e618aa2e.js"><link rel="prefetch" href="/assets/js/9.50d0b6bd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6ba01dbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">桂伦铝's blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/transfer/" class="nav-link">翻译</a></div><div class="nav-item"><a href="/learning/" class="nav-link router-link-active">学习笔记</a></div><div class="nav-item"><a href="https://github.com/ye125440" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/transfer/" class="nav-link">翻译</a></div><div class="nav-item"><a href="/learning/" class="nav-link router-link-active">学习笔记</a></div><div class="nav-item"><a href="https://github.com/ye125440" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>学习笔记</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/learning/HTTP 1.1 协议.html" class="active sidebar-link">HTTP/1.1 协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#短连接与长连接" class="sidebar-link">短连接与长连接</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#host-头部" class="sidebar-link">Host 头部</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#代理服务器转发消息时的相关头部" class="sidebar-link">代理服务器转发消息时的相关头部</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#请求和响应的上下文头部" class="sidebar-link">请求和响应的上下文头部</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#请求" class="sidebar-link">请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#响应" class="sidebar-link">响应</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#内容协商与资源表述" class="sidebar-link">内容协商与资源表述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#内容协商" class="sidebar-link">内容协商</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#html-form-表单" class="sidebar-link">HTML Form 表单</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#表单提交" class="sidebar-link">表单提交</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#多线程、断点续传、随机点播等场景的步骤" class="sidebar-link">多线程、断点续传、随机点播等场景的步骤</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#http-range-规范" class="sidebar-link">HTTP Range 规范</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#服务器响应-一" class="sidebar-link">服务器响应(一)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#服务器响应-二" class="sidebar-link">服务器响应(二)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#多重范围与-multipart" class="sidebar-link">多重范围与 multipart</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cookie-的格式与约束" class="sidebar-link">Cookie 的格式与约束</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cookie-与-set-cookie-头部的定义" class="sidebar-link">Cookie 与 Set-Cookie 头部的定义</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#set-cookie-中描述-cookie-pair-的属性" class="sidebar-link">Set-Cookie 中描述 cookie-pair 的属性</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cookie-使用的限制" class="sidebar-link">Cookie 使用的限制</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cookie-在协议设计上的问题" class="sidebar-link">Cookie 在协议设计上的问题</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#登录场景下-cookie-与-session-的常见用法" class="sidebar-link">登录场景下 Cookie 与 Session 的常见用法</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#无状态的-rest-架构-vs-状态管理" class="sidebar-link">无状态的 REST 架构 VS 状态管理</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#第三方-cookie" class="sidebar-link">第三方 Cookie</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#为什么需要同源策略" class="sidebar-link">为什么需要同源策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#同一个浏览器发出的请求，未必都是用户自愿发出的请求" class="sidebar-link">同一个浏览器发出的请求，未必都是用户自愿发出的请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#站点-domain-b-com-收到的来自同一浏览器的请求，可能来自于站点-domain-a-com" class="sidebar-link">站点 domain-b.com 收到的来自同一浏览器的请求，可能来自于站点 domain-a.com</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#浏览器的同源策略" class="sidebar-link">浏览器的同源策略</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#安全性与可用性需要一个平衡点" class="sidebar-link">安全性与可用性需要一个平衡点</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#跨站请求伪造攻击" class="sidebar-link">跨站请求伪造攻击</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cors-cross-origin-resource-sharing" class="sidebar-link">CORS: Cross-Origin Resource Sharing</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#浏览器同源策略下的跨域访问解决方案" class="sidebar-link">浏览器同源策略下的跨域访问解决方案</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#简单请求的跨域访问" class="sidebar-link">简单请求的跨域访问</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#预检请求" class="sidebar-link">预检请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#跨域访问资源：请求头部" class="sidebar-link">跨域访问资源：请求头部</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#跨域访问资源：响应头部" class="sidebar-link">跨域访问资源：响应头部</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#条件请求的作用" class="sidebar-link">条件请求的作用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#资源-uri-与资源表述-representation" class="sidebar-link">资源 URI 与资源表述 Representation</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#precondition-条件请求" class="sidebar-link">Precondition 条件请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#强验证器与弱验证器的概念" class="sidebar-link">强验证器与弱验证器的概念</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#验证器响应头部-一" class="sidebar-link">验证器响应头部(一)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#条件请求头部" class="sidebar-link">条件请求头部</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#缓存更新-一-：首次缓存" class="sidebar-link">缓存更新(一)：首次缓存</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#缓存更新-二-：基于过期缓存发起条件请求" class="sidebar-link">缓存更新(二)：基于过期缓存发起条件请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#增量更新-一" class="sidebar-link">增量更新(一)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#增量更新-二" class="sidebar-link">增量更新(二)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#增量更新-三" class="sidebar-link">增量更新(三)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#增量更新-四" class="sidebar-link">增量更新(四)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#更新丢失问题-一" class="sidebar-link">更新丢失问题(一)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#更新丢失问题-二" class="sidebar-link">更新丢失问题(二)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#更新丢失问题-三-：乐观锁" class="sidebar-link">更新丢失问题(三)：乐观锁</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#更新丢失问题-四-：乐观锁解决首次上传" class="sidebar-link">更新丢失问题(四)：乐观锁解决首次上传</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#缓存的工作原理" class="sidebar-link">缓存的工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#http缓存：为当前请求服用前请求的响应" class="sidebar-link">HTTP缓存：为当前请求服用前请求的响应</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#如果缓存没有过期" class="sidebar-link">如果缓存没有过期</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#如果缓存过期，则继续从服务器验证" class="sidebar-link">如果缓存过期，则继续从服务器验证</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#私有缓存和共享缓存" class="sidebar-link">私有缓存和共享缓存</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#过期的共享缓存—代理服务器" class="sidebar-link">过期的共享缓存—代理服务器</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#缓存实现示意图" class="sidebar-link">缓存实现示意图</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#缓存新鲜度的四种计算方式" class="sidebar-link">缓存新鲜度的四种计算方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#判断缓存是否过期-cache-control" class="sidebar-link">判断缓存是否过期(Cache-Control)</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#age-头部及-current-age-的计算" class="sidebar-link">Age 头部及 current_age 的计算</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#代理服务器缓存中的-age-头部" class="sidebar-link">代理服务器缓存中的 Age 头部</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#复杂的-cache-control" class="sidebar-link">复杂的 Cache-Control</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cache-control-头部" class="sidebar-link">Cache-Control 头部</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cache-control-头部在请求中的值" class="sidebar-link">Cache-Control 头部在请求中的值</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#cache-control-头部在响应中的值" class="sidebar-link">Cache-Control 头部在响应中的值</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#什么样的响应会被缓存" class="sidebar-link">什么样的响应会被缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#使用缓存作为当前请求响应的条件" class="sidebar-link">使用缓存作为当前请求响应的条件</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#为什么需要-uri-重定向" class="sidebar-link">为什么需要 URI 重定向</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#重定向响应返回码" class="sidebar-link">重定向响应返回码</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#web-crawler：网络爬虫" class="sidebar-link">Web crawler：网络爬虫</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#http-协议的基本认证" class="sidebar-link">HTTP 协议的基本认证</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#认证请求" class="sidebar-link">认证请求</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#认证响应" class="sidebar-link">认证响应</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#如何通过-dns-协议解析域名" class="sidebar-link">如何通过 DNS 协议解析域名</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#什么是dns？" class="sidebar-link">什么是DNS？</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#dns-域名结构" class="sidebar-link">DNS 域名结构</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#websockets-解决什么问题" class="sidebar-link">Websockets 解决什么问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#如何及时获得更新？从轮询问到通知" class="sidebar-link">如何及时获得更新？从轮询问到通知</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#chrome-请求列表：分析-websocket" class="sidebar-link">Chrome 请求列表：分析 Websocket</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#支持双向通讯的-websocket" class="sidebar-link">支持双向通讯的 Websocket</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#websocket-的约束" class="sidebar-link">Websocket 的约束</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#websocket-的成本" class="sidebar-link">Websocket 的成本</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#长连接的心跳保持" class="sidebar-link">长连接的心跳保持</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#兼容-http-协议" class="sidebar-link">兼容 HTTP 协议</a></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#设计哲学：在-web-约束下暴露-tcp-给上层" class="sidebar-link">设计哲学：在 Web 约束下暴露 TCP 给上层</a></li></ul></li><li class="sidebar-sub-header"><a href="/learning/HTTP 1.1 协议.html#websocket-协议格式" class="sidebar-link">Websocket 协议格式</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="http-1-1-协议"><a href="#http-1-1-协议" aria-hidden="true" class="header-anchor">#</a> HTTP/1.1 协议</h1> <h2 id="短连接与长连接"><a href="#短连接与长连接" aria-hidden="true" class="header-anchor">#</a> 短连接与长连接</h2> <ul><li>Connection 头部</li> <li>Keep-Alive(HTTP 1.1 默认支持长连接)、Close</li> <li>仅针对当前连接有效 (存在 porxy 代理时，各层之间的 Connection 是独立的)</li></ul> <p>古老的代理服务器：使用 proxy-connection</p> <ul><li>正向代理服务器、反向代理服务器</li></ul> <h2 id="host-头部"><a href="#host-头部" aria-hidden="true" class="header-anchor">#</a> Host 头部</h2> <ul><li>HTTP/1.1 规范要求请求必须加 Host 头部，Host 无、多个、不合法则返回 400</li> <li>nginx 处理 Host 头部</li></ul> <h2 id="代理服务器转发消息时的相关头部"><a href="#代理服务器转发消息时的相关头部" aria-hidden="true" class="header-anchor">#</a> 代理服务器转发消息时的相关头部</h2> <ul><li>X-Forwarded-For/X-Real-IP</li> <li>Max-Forwards 限制代理服务器的最大转发次数</li> <li>Via 指明经过的代理服务器名称及版本</li></ul> <h2 id="请求和响应的上下文头部"><a href="#请求和响应的上下文头部" aria-hidden="true" class="header-anchor">#</a> 请求和响应的上下文头部</h2> <h3 id="请求"><a href="#请求" aria-hidden="true" class="header-anchor">#</a> 请求</h3> <ul><li><p>User-Agent</p></li> <li><p>Referer 浏览器对来自某一页面的请求自动添加的头部 absolute-URI/partial-URI (防盗链)</p> <p>不会被添加的场景：</p> <ul><li>页面来源协议为 'file' 或 'data URI'</li> <li>当前页面采用 HTTP，来源页面采用 HTTPS</li> <li>服务器端常用语统计分析、缓存优化、防盗链</li></ul></li> <li><p>From 告诉服务器联系到爬虫负责人</p></li></ul> <h3 id="响应"><a href="#响应" aria-hidden="true" class="header-anchor">#</a> 响应</h3> <ul><li><p>Server 指明服务器上所用软件的信息</p></li> <li><p>Allow 与 Access-Ranges</p> <ul><li><p>Allow：告诉客户端，服务器上该 URI 对应的资源允许哪些方法的执行</p> <ul><li>Allow: GET, HEAD, PUT</li></ul></li> <li><p>Accept-Ranges：告诉客户端服务器上资源是否允许 range 请求(断点续传等)</p> <ul><li>Accept-Ranges: bytes</li> <li>Accept-Ranges: none</li></ul></li></ul></li></ul> <h2 id="内容协商与资源表述"><a href="#内容协商与资源表述" aria-hidden="true" class="header-anchor">#</a> 内容协商与资源表述</h2> <h3 id="内容协商"><a href="#内容协商" aria-hidden="true" class="header-anchor">#</a> 内容协商</h3> <p>内容协商 每个 URI 指向的资源可以是任何事物，可以有多种不同的表述(不同语言、媒体格式、压缩编码等)。</p> <ul><li><p>主动式 Proactive</p></li> <li><p>Accept: text/*、Accept-Language: en、Accept-Encoding: br, gzip</p></li> <li><p>响应式 Reactive</p> <p>300 Multiple Choices 或者 406 Not Acceptable</p></li></ul> <p>HTTP 包体：承载的消息内容</p> <ul><li><p>请求或者响应都可以携带包体</p> <ul><li>HTTP-message = start-line *(header-field) CRLF [message-body]</li></ul></li> <li><p>发送 HTTP 请求时已经明确包体的全部长度</p> <ul><li>Content-Length</li></ul></li> <li><p>不确定包体长度</p> <ul><li><p>Transfer-Encoding 头部指明使用 Chunk 传输方式(含 Transfer-Encoding 头部后 Content-Length 头部被忽略)</p></li> <li><p>chunked-body = *chunk</p> <p>​                               last-chunk</p> <p>​                               trailer-part(不是所有都支持 TE 头部)</p> <p>​                               CRLF</p></li> <li><p>chunk = chunk-size [chunk-ext] CRLF chunk-data CRLF</p> <ul><li>chunk-size = 1*HEXDIG(16进制)</li> <li>chunk-data = 1*OCTET</li></ul></li></ul></li> <li><p>MIME</p> <ul><li>Content-Type</li></ul></li> <li><p>Content-Disposition(可以设置为访问 URI 之下下载附件不打开网页 inline/attachments)</p></li></ul> <h2 id="html-form-表单"><a href="#html-form-表单" aria-hidden="true" class="header-anchor">#</a> HTML Form 表单</h2> <h3 id="表单提交"><a href="#表单提交" aria-hidden="true" class="header-anchor">#</a> 表单提交</h3> <ul><li>action: 提交时发起 HTTP 请求的 URI</li></ul> <h2 id="多线程、断点续传、随机点播等场景的步骤"><a href="#多线程、断点续传、随机点播等场景的步骤" aria-hidden="true" class="header-anchor">#</a> 多线程、断点续传、随机点播等场景的步骤</h2> <h3 id="http-range-规范"><a href="#http-range-规范" aria-hidden="true" class="header-anchor">#</a> HTTP Range 规范</h3> <ul><li>头部
<ul><li>request 头部: Range: bytes=start-byte-pos &quot;-&quot;</li> <li>response 头部: Content-Range:(见下文)</li></ul></li></ul> <ul><li>允许服务器基于客户端的请求只发送响应包体的一部分给到客户端，客户端自动合成多个片段的包体组合成完整的体积更大的包体
<ul><li>支持断点续传</li> <li>支持多线程下载</li> <li>支持视频播放器实时拖动</li></ul></li> <li>服务器通过 Accept-Range 头部表示是否支持 Range 请求
<ul><li>Accept-Range: bytes/none</li></ul></li> <li>Range 请求范围的单位(基于字节，设包体总长度为 10000)，通过 Range 头部传递请求范围(Range: bytes=0-499)
<ul><li>第1个500字节: bytes=0-499</li> <li>第2个500字节: bytes=500-999</li> <li>最后1个500字节: bytes=-500</li> <li>仅要第1个和最后1个字节: bytes=0-0,-1</li></ul></li> <li>Range 条件请求
<ul><li>如果客户端已经得到了 Range 响应的一部分，并想在这部分响应未过期的情况下，获取其他部分的响应
<ul><li>常与 If-Unmodified-Since 或者 If-Match 头部共同使用</li></ul></li> <li>If-Range = entity-tag/HTTP-date
<ul><li>可以使用 E-Tag 或者 Last-Modified(E-Tag 不同返回 412 状态码)</li></ul></li></ul></li></ul> <h3 id="服务器响应-一"><a href="#服务器响应-一" aria-hidden="true" class="header-anchor">#</a> 服务器响应(一)</h3> <h4 id="_206-partial-content"><a href="#_206-partial-content" aria-hidden="true" class="header-anchor">#</a> 206 Partial Content</h4> <ul><li>Content-Range 头部: 显示当前片段包体在完整包体中的位置</li> <li>Content-Range = byte-content-range/other-content-range
<ul><li>Byte-content-range = byte-unit SP (byte-range-resp/unsatisfied-range)</li> <li>Byte-range-resp = byte-range &quot;/&quot; (complete-length / &quot;*&quot;)
<ul><li>Complete-length = 1*DIGIT
<ul><li>完整资源的带下，如果未知则用 * 代替</li></ul></li> <li>byte-range = first-byte-pos &quot;-&quot; last-byte-pos</li></ul></li></ul></li> <li>例如：
<ul><li>Content-Range: bytes 42-1233/1234</li> <li>Content-Range: bytes 42-1233/* (*代表完整资源大小未知)</li></ul></li></ul> <h3 id="服务器响应-二"><a href="#服务器响应-二" aria-hidden="true" class="header-anchor">#</a> 服务器响应(二)</h3> <h4 id="_416-request-range-not-satisfiable"><a href="#_416-request-range-not-satisfiable" aria-hidden="true" class="header-anchor">#</a> 416 Request Range Not Satisfiable</h4> <ul><li>请求范围不满足实际资源的大小，其中 Content-Range  中的 complete-length 显示完整响应的长度，例如：
<ul><li>Content-Range: bytes */1234</li></ul></li></ul> <h4 id="_200-ok"><a href="#_200-ok" aria-hidden="true" class="header-anchor">#</a> 200 OK</h4> <ul><li>服务器不支持 Range 请求时，则以 200 返回完整的响应包体</li></ul> <h3 id="多重范围与-multipart"><a href="#多重范围与-multipart" aria-hidden="true" class="header-anchor">#</a> 多重范围与 multipart</h3> <ul><li>请求
<ul><li>Range: bytes=0-50, 100-150</li></ul></li> <li>响应
<ul><li>Content-Type: multipart/byteranges; boundary=...</li></ul></li></ul> <h2 id="cookie-的格式与约束"><a href="#cookie-的格式与约束" aria-hidden="true" class="header-anchor">#</a> Cookie 的格式与约束</h2> <p>RFC6265, HTTP State Management Mechanism</p> <p>保存在客户端、由浏览器维护、表示应用状态的 HTTP 头部</p> <ul><li>存放在内存或者磁盘中</li> <li>服务器端生成 Cookie 在响应中通过 Set-Cookie 头部告知客户端(允许多个 Set-Cookie 头部传递多个值 Set-Cookie: k1=v1;k2=v2;... )</li> <li>客户端得到 Cookie 后，后续请求都会自动 Cookie 头部携带至请求中</li></ul> <h3 id="cookie-与-set-cookie-头部的定义"><a href="#cookie-与-set-cookie-头部的定义" aria-hidden="true" class="header-anchor">#</a> Cookie 与 Set-Cookie 头部的定义</h3> <ul><li>Cookie 头部中可以存放多个 name/value 名值对</li> <li>Set-Cookie 头部一次只能传递1个 name/value 名值对，但是响应中可以有多个 Set-Cookie 头部</li></ul> <h3 id="set-cookie-中描述-cookie-pair-的属性"><a href="#set-cookie-中描述-cookie-pair-的属性" aria-hidden="true" class="header-anchor">#</a> Set-Cookie 中描述 cookie-pair 的属性</h3> <p>cookie-av = expires-av / max-age-av / domain-av / path-av / secure-av / httponly-av / extension-av</p> <ul><li>expires-av = &quot;Expires=&quot; sane-cookie-date
<ul><li>cookie 到日期 sane-cookie-date 后失效</li></ul></li> <li>max-age-av = &quot;Max-age=&quot; none-zero-digit *DIGIT
<ul><li>cookie 经过 *DIGIT 秒后失效，max-age 优先级高于 expires</li></ul></li> <li>domain-av = &quot;Domain=&quot; domain-value
<ul><li>指定 cookie 可用于哪些域名，默认可以访问当前域名</li></ul></li> <li>path-av = &quot;Path=&quot; path-value
<ul><li>指定 path 路径下才能使用 cookie</li></ul></li> <li>secure-av = &quot;Secure&quot;
<ul><li>只有使用 TLS/SSL 协议(HTTPS)时才能使用 cookie</li></ul></li> <li>httponly-av = &quot;HttpOnly&quot;
<ul><li>不能使用 JavaScript (Document.cookie、XMLHttpRequest、Request APIs) 访问到 cookie</li></ul></li></ul> <h3 id="cookie-使用的限制"><a href="#cookie-使用的限制" aria-hidden="true" class="header-anchor">#</a> Cookie 使用的限制</h3> <ul><li>RFC 规范对浏览器使用 Cookie 的要求
<ul><li>每条 Cookie 的长度 (包括 name、value 以及描述的属性总长度) 至少要达到 4KB</li> <li>每个域名下至少支持 50 个 Cookie</li> <li>浏览器至少支持 3000 个 Cookie</li></ul></li> <li>代理服务器传递 Cookie 时会有限制</li></ul> <h3 id="cookie-在协议设计上的问题"><a href="#cookie-在协议设计上的问题" aria-hidden="true" class="header-anchor">#</a> Cookie 在协议设计上的问题</h3> <ul><li>Cookie 会被附加在每个 HTTP 请求中，所以无形中增加了流量</li> <li>由于在 HTTP 请求中的 Cookie  是明文传递的，所以安全性成问题 (除非用 HTTPS)</li> <li>Cookie 的大小不应超过 4KB，故对于复杂的存储需求来说是不够用的</li></ul> <h3 id="登录场景下-cookie-与-session-的常见用法"><a href="#登录场景下-cookie-与-session-的常见用法" aria-hidden="true" class="header-anchor">#</a> 登录场景下 Cookie 与 Session 的常见用法</h3> <p>![登录场景下 Cookie 与 Session 的常见用法](/Users/ye/Desktop/Cookie and Session.png)</p> <h3 id="无状态的-rest-架构-vs-状态管理"><a href="#无状态的-rest-架构-vs-状态管理" aria-hidden="true" class="header-anchor">#</a> 无状态的 REST 架构 VS 状态管理</h3> <p><img src="/Users/ye/Desktop/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.png" alt="无状态的 REST 架构 VS 状态管理"></p> <h3 id="第三方-cookie"><a href="#第三方-cookie" aria-hidden="true" class="header-anchor">#</a> 第三方 Cookie</h3> <h4 id="用户踪迹信息的搜集"><a href="#用户踪迹信息的搜集" aria-hidden="true" class="header-anchor">#</a> 用户踪迹信息的搜集:</h4> <p>在访问 A 网站时，该网站的某些资源引用自 B 网站(如 img 标签 src=&quot;b&quot;)，获取该资源时响应中会带有 Set-Cookie 头部，后续再登录 B 网站时发送的请求会带有 Cookie 头部，B 网站可以对用户身份有一个初步判断，知道用户曾经访问过 A 网站。</p> <h2 id="为什么需要同源策略"><a href="#为什么需要同源策略" aria-hidden="true" class="header-anchor">#</a> 为什么需要同源策略</h2> <h3 id="同一个浏览器发出的请求，未必都是用户自愿发出的请求"><a href="#同一个浏览器发出的请求，未必都是用户自愿发出的请求" aria-hidden="true" class="header-anchor">#</a> 同一个浏览器发出的请求，未必都是用户自愿发出的请求</h3> <p>请求页面的 HTML 后，浏览器的渲染引擎会自动请求需要的资源文件，css、img 等。</p> <h3 id="站点-domain-b-com-收到的来自同一浏览器的请求，可能来自于站点-domain-a-com"><a href="#站点-domain-b-com-收到的来自同一浏览器的请求，可能来自于站点-domain-a-com" aria-hidden="true" class="header-anchor">#</a> 站点 domain-b.com 收到的来自同一浏览器的请求，可能来自于站点 domain-a.com</h3> <ul><li>用户访问的 domain-a.com 使用了 domain-b.com 的资源，向其发起请求</li> <li>用户直接访问 domain-b.com</li></ul> <h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" aria-hidden="true" class="header-anchor">#</a> 浏览器的同源策略</h3> <p>协议(scheme)、主机(domain)、端口(port)必须完全相同</p> <h3 id="安全性与可用性需要一个平衡点"><a href="#安全性与可用性需要一个平衡点" aria-hidden="true" class="header-anchor">#</a> 安全性与可用性需要一个平衡点</h3> <h4 id="可用性：html-创作者决定跨域请求是否对本站点安全"><a href="#可用性：html-创作者决定跨域请求是否对本站点安全" aria-hidden="true" class="header-anchor">#</a> 可用性：HTML 创作者决定跨域请求是否对本站点安全</h4> <ul><li></li> <li><p>允许跨域写操作：例如表单提交或者重定向请求</p> <ul><li>CSRF 安全性问题</li></ul></li></ul> <h4 id="安全性：浏览器需要防止站点-a-的脚本向站点-b-发起危险动作"><a href="#安全性：浏览器需要防止站点-a-的脚本向站点-b-发起危险动作" aria-hidden="true" class="header-anchor">#</a> 安全性：浏览器需要防止站点 A 的脚本向站点 B 发起危险动作</h4> <ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li> <li>DOM 无法获得(防止跨域脚本篡改 DOM 结构)</li> <li>AJAX 请求不能发送</li></ul> <h3 id="跨站请求伪造攻击"><a href="#跨站请求伪造攻击" aria-hidden="true" class="header-anchor">#</a> 跨站请求伪造攻击</h3> <p><img src="/Users/ye/Desktop/CSRF.png" alt="跨站请求伪造攻击"></p> <p>防止攻击：</p> <ul><li>refer</li> <li>CSRF token</li></ul> <h2 id="cors-cross-origin-resource-sharing"><a href="#cors-cross-origin-resource-sharing" aria-hidden="true" class="header-anchor">#</a> CORS: Cross-Origin Resource Sharing</h2> <h3 id="浏览器同源策略下的跨域访问解决方案"><a href="#浏览器同源策略下的跨域访问解决方案" aria-hidden="true" class="header-anchor">#</a> 浏览器同源策略下的跨域访问解决方案</h3> <ul><li>如果站点 A 允许站点 B 的脚本访问其资源，必须在 HTTP 响应中显式的告知浏览器
<ul><li>访问站点 A 的请求，浏览器应该告知该请求来自站点 B 还是用户意愿</li> <li>站点 A 的响应中应明确哪些跨域请求时被允许的</li></ul></li> <li>策略1：何为简单请求？
<ul><li>GET/HEAD/POST 方法之一</li> <li>仅能使用 CORS 安全的头部：Accept、Accept-Language、Content-Length、Content-Type</li> <li>Content-Type 值只能是：text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一</li></ul></li> <li>策略2：简单请求以外的请求
<ul><li>预检机制，先发起一个 OPTIONS 请求，询问何种请求时被允许的</li></ul></li></ul> <h3 id="简单请求的跨域访问"><a href="#简单请求的跨域访问" aria-hidden="true" class="header-anchor">#</a> 简单请求的跨域访问</h3> <ul><li>请求中携带 Origin 头部告知来自哪个域</li> <li>响应中携带 Access-Control-Allow-Origin 头部表示允许哪些域</li> <li>浏览器放行</li></ul> <p>整个控制过程由浏览器执行，在请求时带上了 Origin 头部，服务端只是返回 Access-Control-Allow-Origin 头部，浏览器判断后决定是否允许。即便不传 Origin 头部，服务端也会返回 ACAO 头部。</p> <h3 id="预检请求"><a href="#预检请求" aria-hidden="true" class="header-anchor">#</a> 预检请求</h3> <ul><li>预检请求头部(OPTION 方法)
<ul><li>Access-Control-Request-Method</li> <li>Access-COntrol-Request-Headers</li></ul></li> <li>预检请求响应
<ul><li>Access-Control-Allow-Method</li> <li>Access-Control-Allow-Headers</li> <li>Access-Control-Max-Age</li></ul></li></ul> <h3 id="跨域访问资源：请求头部"><a href="#跨域访问资源：请求头部" aria-hidden="true" class="header-anchor">#</a> 跨域访问资源：请求头部</h3> <p><img src="/Users/ye/Desktop/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8.png" alt="跨域访问资源：请求头部"></p> <h3 id="跨域访问资源：响应头部"><a href="#跨域访问资源：响应头部" aria-hidden="true" class="header-anchor">#</a> 跨域访问资源：响应头部</h3> <p><img src="/Users/ye/Desktop/%E8%B7%A8%E5%9F%9F%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8.png" alt="跨域访问资源：响应头部"></p> <h2 id="条件请求的作用"><a href="#条件请求的作用" aria-hidden="true" class="header-anchor">#</a> 条件请求的作用</h2> <h3 id="资源-uri-与资源表述-representation"><a href="#资源-uri-与资源表述-representation" aria-hidden="true" class="header-anchor">#</a> 资源 URI 与资源表述 Representation</h3> <p>![资源 URI 与资源表述 Representation](/Users/ye/Desktop/资源 URI.png)</p> <h3 id="precondition-条件请求"><a href="#precondition-条件请求" aria-hidden="true" class="header-anchor">#</a> Precondition 条件请求</h3> <h4 id="目的"><a href="#目的" aria-hidden="true" class="header-anchor">#</a> 目的</h4> <ul><li>由客户端携带条件判断信息，而服务器预执行验证过程成功后，再返回资源的表述</li></ul> <h4 id="常用应用场景"><a href="#常用应用场景" aria-hidden="true" class="header-anchor">#</a> 常用应用场景</h4> <ul><li>使缓存的更新更有效(如 304 响应码使服务器不用传递包体)</li> <li>断点续传时对之前内容的验证</li> <li>当多个客户端并行修改同一资源时，防止某一客户端的更新被错误丢弃</li></ul> <h3 id="强验证器与弱验证器的概念"><a href="#强验证器与弱验证器的概念" aria-hidden="true" class="header-anchor">#</a> 强验证器与弱验证器的概念</h3> <ul><li>验证器 validator： 根据客户端请求中携带的相关头部，以及服务器资源的信息，执行两端的资源验证
<ul><li>强验证器：服务器上的资源表述只要有变动(例如版本更新或者元数据更新)，那么以旧的验证头部访问一定会导致验证不过</li> <li>弱验证器：服务器上资源变动时，允许一定程度上仍然可以验证通过(例如一小段时间内仍然允许缓存有效)</li></ul></li></ul> <h3 id="验证器响应头部-一"><a href="#验证器响应头部-一" aria-hidden="true" class="header-anchor">#</a> 验证器响应头部(一)</h3> <ul><li><p>Etag 响应头部</p> <ul><li><p>定义：</p> <p>ETag = entity-tag</p> <p>entity-tag = [ weak ] opague-tag</p> <p>weak = %x57.2F</p> <p>opaque-tag = DQUOTE *etag DQUOTE</p> <p>etagc = %x21 / %x23-7E / obs-text</p></li> <li><p>给出当前资源表述的标签</p></li> <li><p>例如：</p> <ul><li>强验证器 ETag: &quot;xyzzy&quot;</li> <li>弱验证器 ETag: W/&quot;xyzzy&quot;(0x57 = W .2F = /)</li></ul></li></ul></li> <li><p>Last-Modified 响应头部</p> <ul><li>定义：Last-Modified = HTTP-date</li> <li>表示对应资源描述的上次修改时间</li> <li>对比 Date 头部：Date = HTTP-date
<ul><li>表示响应包体生成的时间</li> <li>Last-Modified 不能晚于 Date 的值</li></ul></li></ul></li></ul> <h3 id="条件请求头部"><a href="#条件请求头部" aria-hidden="true" class="header-anchor">#</a> 条件请求头部</h3> <p>F-match =* 1 fentity-tag  If-modified-since=http-date If-unmodified-since=http-date f-range entity-tag/ HT Tp-date</p> <ul><li>If-Match = &quot;*&quot; / 1#entity-tag</li> <li>If-None-Match = &quot;*&quot; / 1#entity-tag</li> <li>If-Modified-Since = / HTTP-date</li> <li>If-Unmodified-Since = HTTP-date</li> <li>If-Range = entity-tag / HTTP-date</li></ul> <h3 id="缓存更新-一-：首次缓存"><a href="#缓存更新-一-：首次缓存" aria-hidden="true" class="header-anchor">#</a> 缓存更新(一)：首次缓存</h3> <p><img src="/Users/ye/Desktop/first-cache.png" alt="缓存更新(一)：首次缓存"></p> <h3 id="缓存更新-二-：基于过期缓存发起条件请求"><a href="#缓存更新-二-：基于过期缓存发起条件请求" aria-hidden="true" class="header-anchor">#</a> 缓存更新(二)：基于过期缓存发起条件请求</h3> <p>缓存的响应超过了过期时间，带上第一次响应的 Last-Modified 和 ETag 头部添加在 If-Modified-Since 和 If-None-Match 头部中发起请求，响应分为资源未修改(304 Not Modified)和已修改(200 OK 返回新的 Last-Modified 和 ETag)两种情况</p> <p><img src="/Users/ye/Desktop/condition-request.png" alt="缓存更新(二)：基于过期缓存发起条件请求"></p> <h3 id="增量更新-一"><a href="#增量更新-一" aria-hidden="true" class="header-anchor">#</a> 增量更新(一)</h3> <p>当服务器支持 Range 服务时，连接意外中断时已接受到部分数据</p> <p><img src="/Users/ye/Desktop/add1.png" alt="增量更新(一)"></p> <h3 id="增量更新-二"><a href="#增量更新-二" aria-hidden="true" class="header-anchor">#</a> 增量更新(二)</h3> <p>通过 Range 请求下载其他包体时，加入验证器防止两次下载间资源已发生了变更</p> <p><img src="/Users/ye/Desktop/add2.png" alt="增量更新(二)"></p> <h3 id="增量更新-三"><a href="#增量更新-三" aria-hidden="true" class="header-anchor">#</a> 增量更新(三)</h3> <p>如果两次下载操作中，资源已经变化，则服务器用 412 Precondition Failed 通知客户端，而客户端重新下载完整包体。412 响应则会发出第二次的请求。</p> <p><img src="/Users/ye/Desktop/add3.png" alt="增量更新(三)"></p> <h3 id="增量更新-四"><a href="#增量更新-四" aria-hidden="true" class="header-anchor">#</a> 增量更新(四)</h3> <p>通过 If-Range 头部可以避免 2 次请求交互带来的损耗，用 If-Range 代替 If-Match，服务端发现资源变化后直接返回新的资源(200 OK)</p> <p><img src="/Users/ye/Desktop/add4.png" alt="增量更新(四)"></p> <h3 id="更新丢失问题-一"><a href="#更新丢失问题-一" aria-hidden="true" class="header-anchor">#</a> 更新丢失问题(一)</h3> <p>更新资源意味着 2 步操作：先获取资源，再把本地修改后的资源提交</p> <p><img src="/Users/ye/Desktop/update-lost1.png" alt="更新丢失问题(一)"></p> <h3 id="更新丢失问题-二"><a href="#更新丢失问题-二" aria-hidden="true" class="header-anchor">#</a> 更新丢失问题(二)</h3> <p>2 个客户端并发修改同一资源会导致更新丢失(下图中 Client 1 的更新丢失了)</p> <p><img src="/Users/ye/Desktop/update-lost2.png" alt="更新丢失问题(二)"></p> <h3 id="更新丢失问题-三-：乐观锁"><a href="#更新丢失问题-三-：乐观锁" aria-hidden="true" class="header-anchor">#</a> 更新丢失问题(三)：乐观锁</h3> <p>只允许第 1 个提交更新的客户端更新资源，Client 2 提交时附加验证头部，Client 1 的修改导致 Client 2 的头部验证通不过。</p> <p><img src="/Users/ye/Desktop/update-lost3.png" alt="更新丢失问题(三)"></p> <h3 id="更新丢失问题-四-：乐观锁解决首次上传"><a href="#更新丢失问题-四-：乐观锁解决首次上传" aria-hidden="true" class="header-anchor">#</a> 更新丢失问题(四)：乐观锁解决首次上传</h3> <p><img src="/Users/ye/Desktop/update-lost4.png" alt="更新丢失问题(四)"></p> <p>服务器处理条件请求的常见规则：Nginx</p> <p><img src="/Users/ye/Desktop/nginx-condition-request.png" alt="服务器处理条件请求的常见规则"></p> <p>请求头中的 If-None-Match、If-Modified-Since 和 If-Match、If-Unmodified-Since 使用场景</p> <ul><li><p>If-None-Match、If-Modified-Since：</p> <p>取缓存时使用，意思是如果服务器端的和我本地的不匹配(None-Match)、已修改(Modified-Since)则返回给我新的资源，如果匹配返回 304 客户端使用本地缓存即可</p></li> <li><p>If-Match、If-Unmodified-Since：</p> <p>多人写作修改同一个页面，提交更新时使用。如果我提交时上次的资源和我之前拉取的一致(Mactch)，说明没有其他人提交过，我可以直接提交，如果不一致，说明存在别人的提交，拒绝我的本次提交。类似 git 的 conflict。</p></li></ul> <h2 id="缓存的工作原理"><a href="#缓存的工作原理" aria-hidden="true" class="header-anchor">#</a> 缓存的工作原理</h2> <h3 id="http缓存：为当前请求服用前请求的响应"><a href="#http缓存：为当前请求服用前请求的响应" aria-hidden="true" class="header-anchor">#</a> HTTP缓存：为当前请求服用前请求的响应</h3> <ul><li>目标：减少时延；降低带宽消耗</li> <li>可选而又必要</li></ul> <h3 id="如果缓存没有过期"><a href="#如果缓存没有过期" aria-hidden="true" class="header-anchor">#</a> 如果缓存没有过期</h3> <p>直接使用缓存</p> <h3 id="如果缓存过期，则继续从服务器验证"><a href="#如果缓存过期，则继续从服务器验证" aria-hidden="true" class="header-anchor">#</a> 如果缓存过期，则继续从服务器验证</h3> <ul><li>304 Not Modified 缓存仍然有效(Content-Length: 0)</li> <li>200 OK 返回新的资源</li></ul> <h3 id="私有缓存和共享缓存"><a href="#私有缓存和共享缓存" aria-hidden="true" class="header-anchor">#</a> 私有缓存和共享缓存</h3> <ul><li>私有缓存：仅供一个用户使用的缓存，通常只存在于如浏览器这样的客户端上</li> <li>共享缓存：可以供多个用户的缓存，存在于网络中负责转发消息的代理服务器(对热点资源常使用共享缓存，以减轻资源服务器的压力，并提升网络效率)
<ul><li>Authentication 响应不可被代理服务器缓存</li> <li>正向代理</li> <li>反向代理</li></ul></li></ul> <h3 id="过期的共享缓存—代理服务器"><a href="#过期的共享缓存—代理服务器" aria-hidden="true" class="header-anchor">#</a> 过期的共享缓存—代理服务器</h3> <p><img src="/Users/ye/Desktop/share-cache.png" alt="过期的共享缓存—代理服务器"></p> <p>响应中的 age 头部表明请求的资源已经在代理服务器上存在了多久。</p> <p>代理服务器上的资源达到过期时间后也会向末端服务器请求最新资源，同样有两种验证结果。代理服务器会重置 age 为 0。</p> <h3 id="缓存实现示意图"><a href="#缓存实现示意图" aria-hidden="true" class="header-anchor">#</a> 缓存实现示意图</h3> <p><img src="/Users/ye/Desktop/cache-implement.png" alt="缓存实现示意图"></p> <h2 id="缓存新鲜度的四种计算方式"><a href="#缓存新鲜度的四种计算方式" aria-hidden="true" class="header-anchor">#</a> 缓存新鲜度的四种计算方式</h2> <h3 id="判断缓存是否过期-cache-control"><a href="#判断缓存是否过期-cache-control" aria-hidden="true" class="header-anchor">#</a> 判断缓存是否过期(Cache-Control)</h3> <p><img src="/Users/ye/Desktop/cache-judge.png" alt="判断缓存是否过期"></p> <p>s-maxage 用于共享缓存，优先级最高。</p> <h4 id="为什么要预估过期时间"><a href="#为什么要预估过期时间" aria-hidden="true" class="header-anchor">#</a> 为什么要预估过期时间</h4> <p>超过一半的请求没有带缓存相关头部，但资源本身又很少变化，浏览器仍会对其进行缓存</p> <h4 id="常见的预估时间"><a href="#常见的预估时间" aria-hidden="true" class="header-anchor">#</a> 常见的预估时间</h4> <ul><li><p>RFC7234 推荐：(DownloadTime - LastModified)*10%</p> <p>浏览器获取到资源的时间 - 上次修改的时间</p></li></ul> <h3 id="age-头部及-current-age-的计算"><a href="#age-头部及-current-age-的计算" aria-hidden="true" class="header-anchor">#</a> Age 头部及 current_age 的计算</h3> <p><img src="/Users/ye/Desktop/age-header.png" alt="Age 头部及 current_age 的计算"></p> <h3 id="代理服务器缓存中的-age-头部"><a href="#代理服务器缓存中的-age-头部" aria-hidden="true" class="header-anchor">#</a> 代理服务器缓存中的 Age 头部</h3> <p><img src="/Users/ye/Desktop/proxy-age.png" alt="代理服务器缓存中的 Age 头部"></p> <h2 id="复杂的-cache-control"><a href="#复杂的-cache-control" aria-hidden="true" class="header-anchor">#</a> 复杂的 Cache-Control</h2> <h3 id="cache-control-头部"><a href="#cache-control-头部" aria-hidden="true" class="header-anchor">#</a> Cache-Control 头部</h3> <p><img src="/Users/ye/Desktop/cache-control-header.png" alt="Cache-Control 头部"></p> <p>头部中颜色区分</p> <ul><li>黑色：只有 token 部分</li> <li>红色：token = &quot;&quot;</li> <li>蓝色：token = &quot;&quot;</li></ul> <h3 id="cache-control-头部在请求中的值"><a href="#cache-control-头部在请求中的值" aria-hidden="true" class="header-anchor">#</a> Cache-Control 头部在请求中的值</h3> <ul><li>max-age：告诉服务器，客户端不会接受 Age 超过 max-age 的缓存</li> <li>max-stale：告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出 max-stale 时，客户端仍打算使用。若 max-stale 后没有值，则表示无论过期多久客户端都可使用</li> <li>min-fresh：告诉服务器，Age 至少经过 min-fresh 秒后缓存才可使用</li> <li>no-cache：告诉服务器，不能直接使用已有缓存作为相应返回，除非带着缓存条件到上游服务端得到 304 验证返回码才可使用现有缓存</li> <li>no-store：告诉各代理服务器不要对该请求的响应缓存(实际有不少不遵守该规定的代理服务器)</li> <li>no-transform：告诉代理服务器不要修改消息包体的内容</li> <li>only-if-cached：告诉服务器仅能返回缓存的响应，若没有缓存则返回 504 错误码</li></ul> <h3 id="cache-control-头部在响应中的值"><a href="#cache-control-头部在响应中的值" aria-hidden="true" class="header-anchor">#</a> Cache-Control 头部在响应中的值</h3> <ul><li>must-revalidate：告诉客户端一旦缓存过期，必须向服务器验证后才可使用</li> <li>proxy-revalidate：与 must-revalidate 类似但它仅对代理服务器的共享缓存有效</li> <li>no-cache：告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证得到 304 返回码。如果 no-cache 后指定头部，则若客户端的后续请求及响应中不含有这些头则可直接使用缓存</li> <li>max-age：告诉客户端缓存 Age 超过 max-age 秒后则缓存过期</li></ul> <h2 id="什么样的响应会被缓存"><a href="#什么样的响应会被缓存" aria-hidden="true" class="header-anchor">#</a> 什么样的响应会被缓存</h2> <ul><li>请求方法可以被缓存理解(不止于 GET 方法)</li> <li>响应码可以被缓存理解(404、206、301 的原请求也可以被缓存)</li> <li>响应与请求的头部没有指明 no-store</li> <li>响应中至少应含有以下头部中的 1 个或多个：
<ul><li>Expires、max-age、s-maxage、public</li> <li>当响应中没有明确指示过期时间的头部时，如果响应码非常明确，也可以缓存</li></ul></li> <li>如果缓存在代理服务器上
<ul><li>不含有 private</li> <li>不含有 Authorization</li></ul></li></ul> <h3 id="使用缓存作为当前请求响应的条件"><a href="#使用缓存作为当前请求响应的条件" aria-hidden="true" class="header-anchor">#</a> 使用缓存作为当前请求响应的条件</h3> <ul><li>URI 是匹配的
<ul><li>URI 作为主要的缓存关键字，当一个 URI 对应多份缓存时选择日期最近的缓存</li> <li>例如 Nginx 中默认的缓存关键字：proxy_cache_key $scheme$proxy_host$request_uri</li></ul></li> <li>缓存中的响应允许当前请求的方法使用缓存</li> <li>缓存中的响应 Vary 头部指定的头部必须与请求中的头部相匹配
<ul><li>Vary = &quot;*&quot; / 1#field-name
<ul><li>Vary: * 意味着一定匹配失败</li></ul></li></ul></li> <li>当前请求以及缓存中的响应都不包含 no-cache 头部(Pragma: no-cache 或者 Cache-Control: no-cache)</li> <li>缓存中的响应必须是一下三者之一：
<ul><li>新鲜的(时间上未过期)</li> <li>缓存中的响应头部明确告知可以使用过期的头部(如  Cache-Control: max-stale=60)</li> <li>使用条件请求去服务器端验证请求是否过期，得到 304 响应</li></ul></li></ul> <h2 id="为什么需要-uri-重定向"><a href="#为什么需要-uri-重定向" aria-hidden="true" class="header-anchor">#</a> 为什么需要 URI 重定向</h2> <ul><li>提交 Form 表单成功后需要显示内容页</li> <li>站点从 HTTP 迁移到 HTTPS</li> <li>站点部分 URI 发生变化，但搜索引擎或者流量入口站点只收录了老的 URI</li> <li>站点正在维护中，需要给用户展示不一样的内容</li> <li>站点更换了域名</li></ul> <h3 id="重定向响应返回码"><a href="#重定向响应返回码" aria-hidden="true" class="header-anchor">#</a> 重定向响应返回码</h3> <ul><li>概念
<ul><li>原请求：接收到重定向响应码的请求</li> <li>重定向请求：浏览器接收到重定向响应码后，会发起新的重定向请求</li></ul></li> <li>永久重定向(会被缓存)，表示资源永久性变更到新 URI
<ul><li>301(HTTP/1.0)：重定向请求通常会使用 GET 方法，而不管原请求究竟采用的是什么方法</li> <li>308(HTTP/1.1)：重定向请求必须使用原请求的方法和包体发起访问</li></ul></li> <li>临时重定向，表示资源只是临时的变更 URI
<ul><li>302(HTTP/1.0)：重定向请求通常会使用 GET 方法，而不管原请求究竟采用的是什么方法</li> <li>303(HTTP/1.1)：它并不表示资源变迁，而是用新 URI 的响应表述而为原请求服务，重定向请求会使用 GET 方法，会丢弃包体数据
<ul><li>例如表单请求后为用户返回新内容</li></ul></li> <li>307(HTTP/1.1)：重定向请求必须使用原请求的方法和包体发起访问
<ul><li>例如访问 http://www.baidu.com 返回 307 带 Location: https://www.baidu.com</li></ul></li></ul></li> <li>特殊重定向
<ul><li>300：响应式内容协商中，告知客户端有多种资源表述，要求客户端选择一种自认为合适的表述</li> <li>304：服务器端验证过期缓存有效后，要求客户端使用该缓存</li></ul></li></ul> <h2 id="web-crawler：网络爬虫"><a href="#web-crawler：网络爬虫" aria-hidden="true" class="header-anchor">#</a> Web crawler：网络爬虫</h2> <h2 id="http-协议的基本认证"><a href="#http-协议的基本认证" aria-hidden="true" class="header-anchor">#</a> HTTP 协议的基本认证</h2> <h3 id="认证请求"><a href="#认证请求" aria-hidden="true" class="header-anchor">#</a> 认证请求</h3> <ul><li>Authorization 头部，如 Authorization: Basic YWFhOmJiYg==</li></ul> <h3 id="认证响应"><a href="#认证响应" aria-hidden="true" class="header-anchor">#</a> 认证响应</h3> <ul><li>在响应头部中应告知客户端需要认证
<ul><li>WWW-Authenticate 头部</li></ul></li> <li>由代理服务器认证
<ul><li>Proxy-Authenticate 头部</li></ul></li> <li>认证响应码
<ul><li>由源服务器告诉客户端需要传递认证信息：401 Unauthorized</li> <li>有代理服务器认证：407 Proxy Authentication Required</li> <li>认证失败：403 Forbidden(也有 401 的实现)</li></ul></li></ul> <h2 id="如何通过-dns-协议解析域名"><a href="#如何通过-dns-协议解析域名" aria-hidden="true" class="header-anchor">#</a> 如何通过 DNS 协议解析域名</h2> <h3 id="什么是dns？"><a href="#什么是dns？" aria-hidden="true" class="header-anchor">#</a> 什么是DNS？</h3> <ul><li><em>Domain Name System</em> 一个用于将人类可读的&quot;域名&quot;(www.baidu.com)与服务器IP地址(116.62.160.193)进行映射的数据库</li> <li>递归查询
<ul><li>根域名服务器</li> <li>权威服务器</li></ul></li></ul> <h3 id="dns-域名结构"><a href="#dns-域名结构" aria-hidden="true" class="header-anchor">#</a> DNS 域名结构</h3> <p>树状，顶级域名—&gt;层层向下</p> <h2 id="websockets-解决什么问题"><a href="#websockets-解决什么问题" aria-hidden="true" class="header-anchor">#</a> Websockets 解决什么问题</h2> <h3 id="如何及时获得更新？从轮询问到通知"><a href="#如何及时获得更新？从轮询问到通知" aria-hidden="true" class="header-anchor">#</a> 如何及时获得更新？从轮询问到通知</h3> <p><img src="/Users/ye/Desktop/websockets.png" alt="从轮询问到通知"></p> <h3 id="chrome-请求列表：分析-websocket"><a href="#chrome-请求列表：分析-websocket" aria-hidden="true" class="header-anchor">#</a> Chrome 请求列表：分析 Websocket</h3> <ul><li>过滤器
<ul><li>按类型：WS</li> <li>属性过滤：is:running</li></ul></li> <li>表格列
<ul><li>Data：消息负载。如果消息为纯文本，则在此处显示。对于二进制操作码，此列将显示操作码的名称和代码。支持一下操作码：Continuation、Frame、Binary Frame、Connection Close Frame、Ping Frame 和 Pong Frame</li> <li>Length：消息负载的长度(以字节为单位)</li> <li>Time：收到或发送消息的时间</li></ul></li> <li>消息颜色
<ul><li>发送至服务器的文本消息为浅绿色</li> <li>接收到的文本消息为白色</li> <li>Websocket 的操作码为浅黄色</li> <li>错误为浅红色</li></ul></li></ul> <h3 id="支持双向通讯的-websocket"><a href="#支持双向通讯的-websocket" aria-hidden="true" class="header-anchor">#</a> 支持双向通讯的 Websocket</h3> <ul><li>RFC6455(2011.12)</li> <li>双向通讯的优劣
<ul><li>可伸缩性较差</li></ul></li> <li>如何管理会话</li> <li>如何维持长连接</li> <li>兼容 HTTP 协议
<ul><li>端口服用</li></ul></li> <li>支持扩展
<ul><li>如 permessage-deflate 扩展(压缩)</li></ul></li></ul> <h2 id="websocket-的约束"><a href="#websocket-的约束" aria-hidden="true" class="header-anchor">#</a> Websocket 的约束</h2> <h3 id="websocket-的成本"><a href="#websocket-的成本" aria-hidden="true" class="header-anchor">#</a> Websocket 的成本</h3> <ul><li>实时性与可伸缩性
<ul><li>牺牲了简单性：在 HTTP 请求中，多个请求分多次发送，可以通过负载均衡等减轻服务器压力。Websocket 多个请求只有一个 websocket 连接，需要进行分层架构。</li></ul></li> <li>网络效率与无状态：请求 2  基 于请求 1
<ul><li>牺牲了简单性与可见性</li></ul></li></ul> <h3 id="长连接的心跳保持"><a href="#长连接的心跳保持" aria-hidden="true" class="header-anchor">#</a> 长连接的心跳保持</h3> <ul><li>HTTP 长连接只能基于简单的超时(常见为 65 秒)</li> <li>Websocket 连接基于 ping/pong 心跳机制维持</li></ul> <h3 id="兼容-http-协议"><a href="#兼容-http-协议" aria-hidden="true" class="header-anchor">#</a> 兼容 HTTP 协议</h3> <ul><li>默认使用 80 或者 443 端口</li> <li>协议升级</li> <li>代理服务器可以简单支持</li></ul> <h3 id="设计哲学：在-web-约束下暴露-tcp-给上层"><a href="#设计哲学：在-web-约束下暴露-tcp-给上层" aria-hidden="true" class="header-anchor">#</a> 设计哲学：在 Web 约束下暴露 TCP 给上层</h3> <ul><li>元数据去哪了？
<ul><li>对比：HTTP 协议头部会存放元数据</li> <li>由 Websocket 上传输的应用层存放元数据</li></ul></li> <li>基于帧：不是基于流（HTTP、TCP)
<ul><li>每一帧要么承载字符数据，要么承载二进制数据</li></ul></li> <li>基于浏蛲器的同源策略槙型（非浏览器无效）
<ul><li>可以使用 Access-Control-Alow-Origin 等头部</li></ul></li> <li>基于 URI、子协议支持同主机同端口上的多个服务</li></ul> <h2 id="websocket-协议格式"><a href="#websocket-协议格式" aria-hidden="true" class="header-anchor">#</a> Websocket 协议格式</h2></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.289f11c2.js" defer></script><script src="/assets/js/2.8eeab113.js" defer></script>
  </body>
</html>
