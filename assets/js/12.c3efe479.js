(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{174:function(t,e,s){"use strict";s.r(e);var n=s(0),i=Object(n.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("原文地址："),s("a",{attrs:{href:"https://blog.usejournal.com/vue-js-best-practices-c5da8d7af48d",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.usejournal.com/vue-js-best-practices-c5da8d7af48d"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("各位开发的小伙伴大家好！")]),t._v(" "),s("p",[t._v("在 "),s("a",{attrs:{href:"https://vuejs.org/v2/guide/",target:"_blank",rel:"noopener noreferrer"}},[t._v("VueJs 文档"),s("OutboundLink")],1),t._v("和网络上研究了一段时间后，我已经创建了一个最佳实践和风格指南的列表，以更正确或更普遍接受的方式使用 VueJs。")]),t._v(" "),s("p",[t._v("以下几点与功能/优化有关，其他是 VueJs 命名约定和元素排序。更详细的信息可以在摘要中的链接中找到。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("当发出/监听自定义事件时，我们应该总是使用短横线命名法。为什么呢？因为无论如何，这些事件都会自动转换成短横线命名。我们永远不会监听用驼峰或帕斯卡命名法命名的事件，因此，把事件名声明为和我们要监听它的方式一样：使用短横线命名法。")]),t._v(" "),t._m(4),t._m(5),t._v(" "),s("p",[t._v("如果我们需要在组件初始化和属性更改时触发一种方法，通常的做法是这样做：")]),t._v(" "),t._m(6),t._m(7),t._v(" "),t._m(8),t._m(9),t._v(" "),s("p",[t._v("总是在模板循环中添加一个 : key 是一种常见的最佳做法。没有 : key 的 v-for 会导致很难找到错误，尤其是在动画中。")]),t._v(" "),t._m(10),t._v(" "),s("p",[t._v("Mixins 是一种很好的方法，可以将重复的代码放入单个块中，并根据需要多次导入，但是(而且是一个很大的但是)，这可能会导致几个问题。在这里，我们将讨论重叠属性的问题。")]),t._v(" "),t._m(11),t._v(" "),s("p",[t._v("为了区分 mixin 属性和组件属性，我们使用$ _。为什么是这些符号？有几个原因:")]),t._v(" "),t._m(12),t._v(" "),s("p",[t._v("在 "),s("a",{attrs:{href:"https://vuejs.org/v2/style-guide/#Private-property-names-essential",target:"_blank",rel:"noopener noreferrer"}},[t._v("VueJs 风格指南"),s("OutboundLink")],1),t._v("中，你会发现他们建议添加mixin的名称，例如: "),s("code",[t._v("$_myMixin_updateUser")]),t._v("。")]),t._v(" "),s("p",[t._v("我发现添加 mixin 名称会让可读性更容易混淆。但是这也取决于混入、情况和开发者。")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),s("p",[t._v("这是一个性能杀手，列表越大，这种糟糕的做法会给性能带来越大的影响。")]),t._v(" "),s("p",[t._v("让我们用代码来解释，想象下面的案例场景:")]),t._v(" "),t._m(15),s("p",[t._v("将按如下方式进行转换：")]),t._v(" "),t._m(16),t._m(17),t._v(" "),t._m(18)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"vuejs-最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuejs-最佳实践","aria-hidden":"true"}},[this._v("#")]),this._v(" VueJs 最佳实践")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"在组件销毁时通过-off-清除事件监听器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在组件销毁时通过-off-清除事件监听器","aria-hidden":"true"}},[this._v("#")]),this._v(" 在组件销毁时通过 $off 清除事件监听器")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当通过 "),e("code",[this._v("$on")]),this._v(" 监听事件时，我们应该永远记住在 "),e("code",[this._v("destroyed()")]),this._v(" 方法中通过 "),e("code",[this._v("$off")]),this._v(" 删除监听者。这防止了我们内存泄漏。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"事件名称始终使用短横线命名法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件名称始终使用短横线命名法","aria-hidden":"true"}},[this._v("#")]),this._v(" 事件名称始终使用短横线命名法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// Emitting\nthis.$emit('my-event') // instead of myEvent\n// Listening\nv-on:my-event\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"避免在-created-和-watch-中调用相同的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免在-created-和-watch-中调用相同的方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 避免在 created 和 watch 中调用相同的方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("watch: {\n  myProperty() {\n    this.doSomething();\n  }\n},\ncreated() {\n  this.doSomething();\n},\nmethods: {\n  doSomething() {\n     console.log('doing something...');\n  }\n},\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("尽管看起来不错，这里使用 "),e("code",[this._v("created ( )")]),this._v(" 是多余的。我们可以将所有的功能都放在 "),e("code",[this._v("watch")]),this._v(" 属性中，从而避免在 "),e("code",[this._v("created ( )")]),this._v(" 中重复代码，并在组件实例化时触发它。例如：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("watch: {\n  myProperty: {\n    immediate: true, // forcing handler on initial status\n    handler() {\n      this.doSomething();\n    }\n  }\n},\nmethods: {\n  doSomething() {\n     console.log('doing something...');\n  }\n},\n// Even better solution\nwatch: {\n  myProperty: {\n    immediate: true, // forcing handler on initial status\n    handler() {\n      console.log('doing something...'); // No need to declare a function on methods for 1 use case\n    }\n  }\n},\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"在-v-for-循环中始终使用-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-v-for-循环中始终使用-key","aria-hidden":"true"}},[this._v("#")]),this._v(" 在 v-for 循环中始终使用 :key")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"将-用于-mixins-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#将-用于-mixins-属性","aria-hidden":"true"}},[this._v("#")]),this._v(" 将$ _用于 mixins 属性")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当我们将 mixin 导入我们的组件时，我们正在将 mixin 代码与我们的组件代码合并，现在，同名的属性怎么办？组件将永远占据上风，组件的属性具有更高的优先级。如果我想让我的 mixin 更有优先权呢？你不能分配优先级，但是你可以通过选择正确的"),e("strong",[this._v("命名约定")]),this._v("来避免属性重叠甚至覆盖。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("来自 VueJs 风格指南的约定")]),this._v(" "),e("li",[this._v("_是为 Vue 的私有属性预留的")]),this._v(" "),e("li",[this._v("$是为 Vue 的生态系统预留的")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通过添加一个简单的 "),e("code",[this._v("$_")]),this._v("， 比如 "),e("code",[this._v("$_updateUser")]),this._v("，我发现代码可读性更强，可以轻松区分组件和 Mixin。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"切勿在与-v-for-相同的元素上使用-v-if"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#切勿在与-v-for-相同的元素上使用-v-if","aria-hidden":"true"}},[this._v("#")]),this._v(" 切勿在与 v-for 相同的元素上使用 v-if")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('<ul>\n  <li\n    v-for="game in games"\n    v-if="game.isActive"\n    :key="game.slug"\n  >\n    {{ game.title }}\n  <li>\n</ul>\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("this.games.map(function (game) {\n  if (game.isActive) {\n    return game.title\n  }\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我们可以在这里看到，我们必须遍历整个 "),e("code",[this._v("games")]),this._v(" 列表，不管 "),e("code",[this._v("game")]),this._v(" 是否已经改变。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在其他框架中，比如 Angular，这种情况就不会编译( "),e("code",[this._v("*ngIf")]),this._v(" 不能在有 "),e("code",[this._v("*ngFor")]),this._v(" 的同一元素中进行编译)。")])}],!1,null,null,null);i.options.__file="VueJs 最佳实践.md";e.default=i.exports}}]);